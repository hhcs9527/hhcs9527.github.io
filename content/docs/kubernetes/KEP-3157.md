---
title: "KEP-3157 Watch List"
type: docs
---

## Problem
For every watcher to read the data from informer, it require to List the data first, then watch the event changes, which brought
	- If there are many watcher, it will operate the same things.
	- Each List will do the following
        1. LIST RV="0" request
           - Require the entire etcd read, which will cause the high mem usage for loading the data
           - The moment where data read it will has the issue, may not consist
        2. WATCH the resource
        3. When the data is either expired or compact, will start from #1


## Solution
Watch list

## Lession learn

### Why does the stream can alleviate the memeory
- stream background is ?
- code where they use the stream
- code experiment, vanilla v.s. my own implementation
### How to get the alert for the apiserver?
### step2.
- upon receiving the request from an informer, contact etcd to get the latest RV. It will be used to make sure the watch cache has seen objects up to the received RV. This step is necessary and ensures we will serve consistent data, even from the cache.
- why can we ensure it upto date?
- cold start of etcd?

### How does sample apiserver works on watch list implementation?

### bookmark event
### list RV = 0



### Env
### Code to test it
### Code to test it
<a id="bookmark-ref"></a>
- … [bookmark](#bookmark-note)

<a id="rv-empty-ref"></a>
- … [RV=""](#rv-empty-note)

<a id="rv-0-ref"></a>
- … [RV=0](#rv-0-note)


### trade off using the RV=0 with CAP
# ResourceVersion 參數對比

## 核心差異

### `RV=""` - 強一致性保證
- **資料來源**: 直接從 etcd 進行 **Quorum Read**
- **一致性**: **強一致性** - 保證獲得最新提交的資料
- **效能代價**: 較高延遲，需要等待多數節點確認
- **使用場景**:
  - Informer 初始化後的一致性同步
  - 錯誤恢復 (410 ResourceExpired)
  - 關鍵操作需要最新狀態時
- **CAP 權衡**: 選擇 **CP** (一致性 + 分區容忍性)

### `RV="0"` - 最佳努力可用性
- **資料來源**: 從 **Watch Cache** 讀取 (如果可用)
- **一致性**: **最終一致性** - 可能返回過時資料
- **效能優勢**: 低延遲，高可用性
- **風險**:
  - 可能讀取到過時狀態
  - 在 HA 環境中可能出現時間倒流
  - Watch cache 可能落後於 etcd
- **CAP 權衡**: 偏向 **AP** (可用性 + 分區容忍性)

## 實際行為對比

| 場景 | `RV=""` | `RV="0"` |
|------|---------|----------|
| 資料新鮮度 | ✅ 保證最新 | ⚠️ 可能過時 |
| 讀取延遲 | 🐌 較高 | ⚡ 較低 |
| 網路分區時 | 🛡️ 拒絕服務保證一致性 | 📱 繼續服務但可能不一致 |
| etcd 負載 | 📈 直接查詢 | 📉 使用快取 |
| 記憶體使用 | 💾 按需分頁 | 💥 可能大量記憶體 |

## 使用建議

### 選擇 `RV=""` 當：
- 需要強一致性保證
- 可以接受較高延遲
- 初始化或錯誤恢復場景
- 安全關鍵操作

### 選擇 `RV="0"` 當：
- 需要低延遲響應
- 可以容忍短暫不一致
- 高頻查詢場景
- 監控或展示用途

## KEP 3157 的改進

新的 Watch-List 方法結合兩者優勢：

```
1. 使用 RV="" 建立一致性基準點
2. 等待 Watch Cache 同步到該基準點
3. 從 Watch Cache 進行高效串流傳輸
```

這種方式既保證了一致性，又避免了記憶體爆炸問題。

## Experiment

## Reference
- [KEP-3157](https://github.com/kubernetes/enhancements/blob/master/keps/sig-api-machinery/3157-watch-list/README.md)

---

### Note

### Note
<a id="bookmark-note"></a>
- **Bookmark Event** — a Kubernetes watch event that notifies the client of the query object's resource version. [↩](#bookmark-ref)

<a id="rv-empty-note"></a>
- RV="" — etcd issues a quorum read, guaranteeing the latest committed data. [↩](#rv-empty-ref)

<a id="rv-0-note"></a>
- RV=0 — etcd serves the request without quorum; the response may be stale. [↩](#rv-0-ref)
